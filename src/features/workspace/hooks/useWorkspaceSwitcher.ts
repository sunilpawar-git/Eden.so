/**
 * useWorkspaceSwitcher - Atomic workspace switching with cache-first pattern
 */
import { useState, useCallback, useRef } from 'react';
import { useAuthStore } from '@/features/auth/stores/authStore';
import { useCanvasStore } from '@/features/canvas/stores/canvasStore';
import { useWorkspaceStore } from '../stores/workspaceStore';
import { loadNodes, loadEdges } from '../services/workspaceService';
import { workspaceCache } from '../services/workspaceCache';
import { useOfflineQueueStore } from '../stores/offlineQueueStore';
import { strings } from '@/shared/localization/strings';

interface UseWorkspaceSwitcherResult {
    isSwitching: boolean;
    error: string | null;
    switchWorkspace: (workspaceId: string) => Promise<void>;
}


export function useWorkspaceSwitcher(): UseWorkspaceSwitcherResult {
    const { user } = useAuthStore();
    const { setNodes, setEdges } = useCanvasStore();
    const currentWorkspaceId = useWorkspaceStore((s) => s.currentWorkspaceId);
    const setCurrentWorkspaceId = useWorkspaceStore((s) => s.setCurrentWorkspaceId);
    const isSwitching = useWorkspaceStore((s) => s.isSwitching);
    const setSwitching = useWorkspaceStore((s) => s.setSwitching);

    const [error, setError] = useState<string | null>(null);
    const switchingRef = useRef(false);


    const switchWorkspace = useCallback(async (workspaceId: string): Promise<void> => {
        // Guard: same workspace or no user
        if (workspaceId === currentWorkspaceId || !user) {
            return;
        }

        // Guard: prevent concurrent switches
        if (switchingRef.current) {
            return;
        }

        switchingRef.current = true;
        setSwitching(true);
        setError(null);
        const startTime = performance.now();

        try {
            // 1. Fire-and-forget save (non-blocking, parallel with load)
            const { nodes: currentNodes, edges: currentEdges } = useCanvasStore.getState();
            if (currentWorkspaceId && (currentNodes.length > 0 || currentEdges.length > 0)) {
                useWorkspaceStore.getState().setNodeCount(currentWorkspaceId, currentNodes.length);

                // Use offline queue for reliable saving, even if currently offline
                useOfflineQueueStore.getState().queueSave(user.id, currentWorkspaceId, currentNodes, currentEdges);
            }

            // 2. Check cache first (instant if cached)
            const cached = workspaceCache.get(workspaceId);
            let newNodes;
            let newEdges;
            let cacheHit = false;

            if (cached) {
                // Cache hit - instant!
                cacheHit = true;
                newNodes = cached.nodes;
                newEdges = cached.edges;
            } else {
                // Cache miss - load from Firestore
                [newNodes, newEdges] = await Promise.all([
                    loadNodes(user.id, workspaceId),
                    loadEdges(user.id, workspaceId),
                ]);
                // Populate cache for next time (writes through to IDB)
                workspaceCache.set(workspaceId, { nodes: newNodes, edges: newEdges, loadedAt: Date.now() });
            }
            const loadTime = performance.now() - startTime;
            console.info(`[WorkspaceSwitcher] Switch completed in ${loadTime.toFixed(2)}ms (cache ${cacheHit ? 'HIT' : 'MISS'})`);

            // 3. Atomic swap: update nodes/edges directly (no clearCanvas)
            setNodes(newNodes);
            setEdges(newEdges);

            // Phase R3: Sync node count explicitly to UI store
            useWorkspaceStore.getState().setNodeCount(workspaceId, newNodes.length);

            // 4. Update workspace ID last
            setCurrentWorkspaceId(workspaceId);

            // 5. Load Knowledge Bank entries for new workspace (non-blocking)
            void (async () => {
                try {
                    const { loadKBEntries } = await import('@/features/knowledgeBank/services/knowledgeBankService');
                    const { useKnowledgeBankStore } = await import('@/features/knowledgeBank/stores/knowledgeBankStore');
                    const kbEntries = await loadKBEntries(user.id, workspaceId);
                    useKnowledgeBankStore.getState().setEntries(kbEntries);
                } catch (err: unknown) {
                    console.error('[useWorkspaceSwitcher] KB load failed:', err);
                }
            })();
        } catch (err) {
            const message = err instanceof Error ? err.message : strings.workspace.switchError;
            setError(message);
            console.error('[useWorkspaceSwitcher]', err);
        } finally {
            setSwitching(false);
            switchingRef.current = false;
        }
    }, [user, currentWorkspaceId, setNodes, setEdges, setCurrentWorkspaceId, setSwitching]);

    return { isSwitching, error, switchWorkspace };
}
