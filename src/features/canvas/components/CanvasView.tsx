/**
 * Canvas View - ReactFlow wrapper component
 * Store is the single source of truth, ReactFlow syncs to it
 */
import { useMemo, useRef, memo, useEffect, useCallback } from 'react';
import { ReactFlow, Background, BackgroundVariant, ConnectionLineType, SelectionMode, PanOnScrollMode, type Node, type Viewport } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import { useCanvasStore } from '../stores/canvasStore';
import { useFocusStore } from '../stores/focusStore';
import { useWorkspaceContext } from '@/app/contexts/WorkspaceContext';
import { useSettingsStore } from '@/shared/stores/settingsStore';
import { workspaceCache } from '@/features/workspace/services/workspaceCache';
import { ZoomControls } from './ZoomControls';
import { FocusOverlay } from './FocusOverlay';
import { ViewportSync } from './ViewportSync';
import { buildRfNodes, cleanupDataShells, type PrevRfNodes } from './buildRfNodes';
import { mapCanvasEdgesToRfEdges } from './canvasChangeHelpers';
import { nodeTypes, edgeTypes, DEFAULT_EDGE_OPTIONS, SNAP_GRID } from './canvasViewConstants';
import { useCanvasHandlers } from '../hooks/useCanvasHandlers';
import styles from './CanvasView.module.css';

function getContainerClassName(isSwitching: boolean): string {
    return isSwitching ? `${styles.canvasContainer ?? ''} ${styles.switching ?? ''}` : (styles.canvasContainer ?? '');
}

function CanvasViewInner() {
    const nodes = useCanvasStore((s) => s.nodes);
    const edges = useCanvasStore((s) => s.edges);
    const selectedNodeIds = useCanvasStore((s) => s.selectedNodeIds);
    const viewport = useCanvasStore((s) => s.viewport);
    const { currentWorkspaceId, isSwitching } = useWorkspaceContext();
    const canvasGrid = useSettingsStore((s) => s.canvasGrid);
    const canvasScrollMode = useSettingsStore((s) => s.canvasScrollMode);
    const isCanvasLocked = useSettingsStore((s) => s.isCanvasLocked);
    const isFocused = useFocusStore((s) => s.focusedNodeId !== null);
    const isInteractionDisabled = isCanvasLocked || isFocused;
    const isNavigateMode = canvasScrollMode === 'navigate';

    const prevRfNodesRef = useRef<PrevRfNodes>({ arr: [], map: new Map() });
    const handlers = useCanvasHandlers(currentWorkspaceId, isCanvasLocked);

    const handleMoveEnd = useCallback((_event: unknown, newViewport: Viewport) => {
        useCanvasStore.getState().setViewport(newViewport);
        if (!currentWorkspaceId) return;
        const cached = workspaceCache.get(currentWorkspaceId);
        if (cached) {
            workspaceCache.set(currentWorkspaceId, { ...cached, viewport: newViewport });
        }
    }, [currentWorkspaceId]);

    const rfNodes: Node[] = useMemo(
        () => buildRfNodes(nodes, selectedNodeIds, prevRfNodesRef),
        [nodes, selectedNodeIds],
    );

    const rfEdges = useMemo(() => mapCanvasEdgesToRfEdges(edges), [edges]);

    useEffect(() => {
        cleanupDataShells(new Set(nodes.map((n) => n.id)));
    }, [nodes]);

    return (
        <div className={getContainerClassName(isSwitching)} data-canvas-container>
            <ReactFlow
                nodes={rfNodes}
                edges={rfEdges}
                onNodesChange={handlers.onNodesChange}
                onEdgesChange={handlers.onEdgesChange}
                onConnect={handlers.onConnect}
                onSelectionChange={handlers.onSelectionChange}
                onMoveEnd={handleMoveEnd}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                connectionLineType={ConnectionLineType.Bezier}
                defaultEdgeOptions={DEFAULT_EDGE_OPTIONS}
                snapToGrid
                snapGrid={SNAP_GRID}
                minZoom={0.1}
                maxZoom={2}
                zoomOnScroll={!isInteractionDisabled && !isNavigateMode}
                panOnScroll={!isInteractionDisabled && isNavigateMode}
                panOnDrag={!isInteractionDisabled}
                nodesDraggable={!isInteractionDisabled}
                noDragClassName="nodrag"
                elementsSelectable={!isInteractionDisabled}
                nodesConnectable={!isInteractionDisabled}
                {...(isNavigateMode && { panOnScrollMode: PanOnScrollMode.Free })}
                selectionOnDrag={!isInteractionDisabled}
                selectionMode={SelectionMode.Partial}
            >
                <ViewportSync viewport={viewport} />
                {canvasGrid && <Background variant={BackgroundVariant.Dots} gap={16} size={1} />}
                <ZoomControls />
            </ReactFlow>
            <FocusOverlay />
        </div>
    );
}

export const CanvasView = memo(CanvasViewInner);
